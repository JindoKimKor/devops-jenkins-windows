def pass = "Pass"
def fail = "Fail"
def util

pipeline {
    agent any

    tools {nodejs "Node"}

    parameters {
        string(name: 'PR_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_DESTINATION_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_REPO_HTML', defaultValue: '', description: '')
        string(name: 'PR_REPO_NAME', defaultValue: '', description: '')
        string(name: 'PR_COMMIT', defaultValue: '', description: '')
        string(name: 'PR_PROJECT', defaultValue: '', description: '')
        string(name: 'PR_STATE', defaultValue: '', description: '')
        string(name: 'TEST_RUN', defaultValue: 'Y', description: 'This is a test run trigger. Fill in the parameter form with \'Y\' to run the pipeline without commit changes.')
    }

    triggers {
        GenericTrigger(
            genericVariables: [
                [key: 'PR_BRANCH', value: '$.pullrequest.source.branch.name'],
                [key: 'PR_DESTINATION_BRANCH', value: '$.pullrequest.destination.branch.name'],
                [key: 'PR_REPO_HTML', value: '$.repository.links.self.href'],
                [key: 'PR_REPO_NAME', value: '$.repository.name'],
                [key: 'PR_COMMIT', value: '$.pullrequest.source.commit.hash'],
                [key: 'PR_PROJECT', value: '$.repository.full_name'],
                [key: 'PR_STATE', value: '$.pullrequest.state']
            ],

            tokenCredentialId: 'trigger-token',
            regexpFilterText: '$PR_STATE',
            regexpFilterExpression: 'OPEN'
        )
    }

    environment {
        CI_PIPELINE = "true"
        PROJECT_DIR = "${WORKSPACE}/JS_Project" 
        REPORT_DIR = "${WORKSPACE}/PRJob/${PR_BRANCH}"
        JOB_REPO = "${PR_REPO_HTML}"
        BITBUCKET_ACCESS_TOKEN = credentials('bitbucket-access-token')
        JENKINS_API_KEY = credentials('jenkins-api-key')
    }

    stages {
        // Prepare Workspace: Environment Setup, Workspace Preparation(Branch Management), Unity Setup, Initial running the project on Unity Editor
        stage('Prepare Workspace') {
            // Environment Setup
            environment {
                REPO_SSH = "git@bitbucket.org:${PR_PROJECT}.git"
                DESTINATION_BRANCH = "${PR_DESTINATION_BRANCH}"
            }
            steps {
                //send 'In Progress' status to Bitbucket
                script {
                    // print jenkins env configurations
                    sh 'env'
                    util = load("${WORKSPACE}/groovy/pipelineUtil.groovy")
                    env.COMMIT_HASH = util.getFullCommitHash(WORKSPACE, PR_COMMIT)
                    dir("${PROJECT_DIR}"){
                        env.CURRENT_HASH = util.getCurrentCommitHash()
                        // confirm if PR commits are updated and if no commits are updated, abort the pipeline
                        if(util.isEqualCommitHash(CURRENT_HASH, COMMIT_HASH && !TEST_RUN.equals("Y"))){
                            env.FAILURE_REASON = "No commits updated. Exiting the pipeline..."
                            currentBuild.result = 'ABORTED'
                            error(env.FAILURE_REASON)
                        }
                    }
                    echo "Sending \'In Progress\' status to Bitbucket..."
                    util.sendBuildStatus(WORKSPACE, "INPROGRESS", COMMIT_HASH)
                    env.TICKET_NUMBER = util.parseTicketNumber(PR_BRANCH)
                    env.FOLDER_NAME = "${JOB_NAME}".split('/').first()
                }
                
                // Workspace Preparation 
                script {
                    // Scenario 1: Project directory does not exist on the VM
                    // Action: Clone the repository to initialize the project directory.
                    echo "Directory Checking if it original project exists"
                    if (!fileExists("${PROJECT_DIR}")) {
                        echo "Cloning repository..."
                        sh "git clone ${REPO_SSH} \"${PROJECT_DIR}\""
                        
                    } else {
                        // Scenario 2: Project directory and .git directory exist
                        // Action: Remove any existing git index lock and fetch the latest updates.
                        if (fileExists("${PROJECT_DIR}/.git")) {
                            sh "rm -f '${PROJECT_DIR}/.git/index.lock'"

                            echo "Fetching latest changes..."
                            dir ("${PROJECT_DIR}") {         

                            sh "git fetch origin"
                            sh "git reset --hard origin/${PR_BRANCH}"
                            }
                        } 
                        // Scenario 3: Project directory exists but .git directory is missing or corrupted
                        // Action: Clean the directory and clone the repository afresh.
                        else { 
                            echo "Cleaning workspace..."
                            sh "rm -rf '${PROJECT_DIR}'"
                            echo "Cloning repository..."
                            sh "git clone ${REPO_SSH} \"${PROJECT_DIR}\""   
                        }
                    }
                }

                dir ("${PROJECT_DIR}") {
                    script {                                           
                        echo "Checking if branch is up to date..."
                        if (util.isBranchUpToDate(DESTINATION_BRANCH) == 0) {
                            echo "Branch is up to date."
                        }
                        else {
                            echo "Branch needs to be updated. Merging destination branch into main..."
                        
                            if (util.tryMerge(DESTINATION_BRANCH) == 0) {
                                echo "Merge successful."
                            }
                            else {
                                sh "git merge --abort"
                                env.FAILURE_REASON = "Merge errors found. Merge aborted."
                                error(env.FAILURE_REASON)
                            }
                        }
                    }
                }   
            }
        }
        stage('Install Dependencies'){
            steps {
                script {
                    script{
                        echo "Dependencies step"
                        echo "Check NPM"
                        sh 'npm config ls'
                        echo "Install dependencies"
                        sh "npm install --prefix '${PROJECT_DIR}'"
                    }
                }
            }
        }
        stage('Linting'){
            steps {
                script {
                    echo "Linting step"
                }
            }
        }
        // Runs the project's EditMode tests, and then generates a test report and a code coverage report.
        // Sends the test results to Bitbucket once the tests complete.
        stage('Tests') {
            steps {
                script {
                    echo "Testing step"
                }
            }
        }
        // Merges the two coverage reports from the EditMode and PlayMode (editor) reports into one.
        // Then sends a coverage report to Bitbucket.
        stage('Generate Code Coverage Report') {
            steps {
                script {
                    echo "Code Coverage step"
                }
            }
        }
        //Builds the project and saves it. containerization?
        stage('Build Project') {
            steps {
                script {
                    echo "Build Step"
                }
            }
        }
    }

    // When the pipeline finishes, sends the build status to Bitbucket.
    post {
        success {
            script {
                util.postBuildJS("SUCCESSFUL")
            }
        }
        failure {
            script {
                util.postBuildJS("FAILED")
            }
        }
        aborted {
            script {
                util.postBuildJS("STOPPED")
            }
        }
    }
}